diff --git a/.output.txt b/.output.txt
deleted file mode 100644
index 4592936..0000000
--- a/.output.txt
+++ /dev/null
@@ -1,273 +0,0 @@
-diff --git a/src/lib.rs b/src/lib.rs
-new file mode 100644
-index 0000000..0a29f8f
---- /dev/null
-+++ b/src/lib.rs
-@@ -0,0 +1,267 @@
-+// Copyright (c) 2025, Lars Wilhelmsen
-+// All rights reserved.
-+//
-+// This source code is licensed under the BSD-3-Clause license found in the
-+// LICENSE file in the root directory of this source tree.
-+
-+use colored::*;
-+use rio_api::model::{Triple, Term, Literal, Subject};
-+use rio_api::parser::TriplesParser;
-+use rio_turtle::{TurtleParser, TurtleError};
-+use std::collections::HashMap;
-+use std::io::{BufReader, Read};
-+use anyhow::Result;
-+
-+pub mod config;
-+
-+// Define a trait for the Args interface
-+pub trait Args {
-+    fn expand(&self) -> bool;
-+}
-+
-+// Re-export the types and functions needed for testing
-+#[derive(Debug)]
-+pub struct OwnedTriple {
-+    pub subject_type: SubjectType,
-+    pub subject_value: String,
-+    pub predicate: String,
-+    pub object_type: ObjectType,
-+    pub object_value: String,
-+    pub object_datatype: Option<String>,
-+    pub object_language: Option<String>,
-+}
-+
-+#[derive(Debug, PartialEq)]
-+pub enum SubjectType {
-+    NamedNode,
-+    BlankNode,
-+}
-+
-+#[derive(Debug, PartialEq)]
-+pub enum ObjectType {
-+    NamedNode,
-+    BlankNode,
-+    Literal,
-+}
-+
-+// Convert a Triple to an OwnedTriple
-+pub fn triple_to_owned(triple: &Triple) -> OwnedTriple {
-+    let (subject_type, subject_value) = match &triple.subject {
-+        Subject::NamedNode(node) => (SubjectType::NamedNode, node.iri.to_string()),
-+        Subject::BlankNode(node) => (SubjectType::BlankNode, node.id.to_string()),
-+        Subject::Triple(_) => (SubjectType::NamedNode, "".to_string()), // Not handling nested triples for simplicity
-+    };
-+
-+    let predicate = triple.predicate.iri.to_string();
-+
-+    let (object_type, object_value, object_datatype, object_language) = match &triple.object {
-+        Term::NamedNode(node) => (ObjectType::NamedNode, node.iri.to_string(), None, None),
-+        Term::BlankNode(node) => (ObjectType::BlankNode, node.id.to_string(), None, None),
-+        Term::Literal(literal) => match literal {
-+            Literal::Simple { value } => (ObjectType::Literal, value.to_string(), None, None),
-+            Literal::LanguageTaggedString { value, language } => (
-+                ObjectType::Literal,
-+                value.to_string(),
-+                None,
-+                Some(language.to_string()),
-+            ),
-+            Literal::Typed { value, datatype } => (
-+                ObjectType::Literal,
-+                value.to_string(),
-+                Some(datatype.iri.to_string()),
-+                None,
-+            ),
-+        },
-+        Term::Triple(_) => (ObjectType::NamedNode, "".to_string(), None, None), // Not handling nested triples for simplicity
-+    };
-+
-+    OwnedTriple {
-+        subject_type,
-+        subject_value,
-+        predicate,
-+        object_type,
-+        object_value,
-+        object_datatype,
-+        object_language,
-+    }
-+}
-+
-+// Format an owned subject
-+pub fn format_owned_subject(triple: &OwnedTriple, prefixes: Option<&HashMap<String, String>>, _colors: &config::ColorConfig) -> String {
-+    match triple.subject_type {
-+        SubjectType::NamedNode => {
-+            if let Some(prefixes) = prefixes {
-+                // Try to use a prefix if available
-+                for (prefix, iri) in prefixes {
-+                    if triple.subject_value.starts_with(iri) {
-+                        let local_part = &triple.subject_value[iri.len()..];
-+                        return format!("{}:{}", prefix, local_part);
-+                    }
-+                }
-+            }
-+
-+            // No prefix found, use full URI
-+            format!("<{}>", triple.subject_value)
-+        },
-+        SubjectType::BlankNode => format!("_:{}", triple.subject_value),
-+    }
-+}
-+
-+// Format an owned predicate
-+pub fn format_owned_predicate(triple: &OwnedTriple, prefixes: Option<&HashMap<String, String>>, colors: &config::ColorConfig) -> String {
-+    if let Some(prefixes) = prefixes {
-+        // Try to use a prefix if available
-+        for (prefix, iri) in prefixes {
-+            if triple.predicate.starts_with(iri) {
-+                let local_part = &triple.predicate[iri.len()..];
-+                return format!("{}:{}", prefix, local_part).color(colors.get_color("predicate")).to_string();
-+            }
-+        }
-+    }
-+
-+    // No prefix found, use full URI
-+    format!("<{}>", triple.predicate).color(colors.get_color("predicate")).to_string()
-+}
-+
-+// Format an owned object
-+pub fn format_owned_object(triple: &OwnedTriple, prefixes: Option<&HashMap<String, String>>, colors: &config::ColorConfig) -> String {
-+    match triple.object_type {
-+        ObjectType::NamedNode => {
-+            if let Some(prefixes) = prefixes {
-+                // Try to use a prefix if available
-+                for (prefix, iri) in prefixes {
-+                    if triple.object_value.starts_with(iri) {
-+                        let local_part = &triple.object_value[iri.len()..];
-+                        return format!("{}:{}", prefix, local_part).color(colors.get_color("object")).to_string();
-+                    }
-+                }
-+            }
-+
-+            // No prefix found, use full URI
-+            format!("<{}>", triple.object_value).color(colors.get_color("object")).to_string()
-+        },
-+        ObjectType::BlankNode => format!("_:{}", triple.object_value).color(colors.get_color("object")).to_string(),
-+        ObjectType::Literal => {
-+            let literal_color = colors.get_color("literal");
-+
-+            if let Some(language) = &triple.object_language {
-+                format!("\"{}\"@{}", triple.object_value, language).color(literal_color).to_string()
-+            } else if let Some(datatype) = &triple.object_datatype {
-+                let datatype_str = if let Some(prefixes) = prefixes {
-+                    // Try to use a prefix if available
-+                    let mut result = format!("<{}>", datatype);
-+                    for (prefix, iri) in prefixes {
-+                        if datatype.starts_with(iri) {
-+                            let local_part = &datatype[iri.len()..];
-+                            result = format!("{}:{}", prefix, local_part);
-+                            break;
-+                        }
-+                    }
-+                    result
-+                } else {
-+                    format!("<{}>", datatype)
-+                };
-+
-+                format!("\"{}\"^^{}", triple.object_value, datatype_str).color(literal_color).to_string()
-+            } else {
-+                format!("\"{}\"", triple.object_value).color(literal_color).to_string()
-+            }
-+        },
-+    }
-+}
-+
-+// Print triples with or without prefixes
-+pub fn print_triples(triples: &[OwnedTriple], prefixes: Option<&HashMap<String, String>>, colors: &config::ColorConfig) {
-+    let mut current_subject: Option<String> = None;
-+
-+    for triple in triples {
-+        let subject = format_owned_subject(triple, prefixes, colors);
-+        let predicate = format_owned_predicate(triple, prefixes, colors);
-+        let object = format_owned_object(triple, prefixes, colors);
-+
-+        // Check if we're continuing with the same subject
-+        if let Some(ref current) = current_subject {
-+            if *current == subject {
-+                // Same subject, print with semicolon
-+                println!("    {} ;", predicate);
-+                println!("        {} .", object);
-+            } else {
-+                // New subject
-+                if current_subject.is_some() {
-+                    println!();  // Add a blank line between statements
-+                }
-+                println!("{}", subject.color(colors.get_color("subject")).bold());
-+                println!("    {} ;", predicate);
-+                println!("        {} .", object);
-+                current_subject = Some(subject);
-+            }
-+        } else {
-+            // First subject
-+            println!("{}", subject.color(colors.get_color("subject")).bold());
-+            println!("    {} ;", predicate);
-+            println!("        {} .", object);
-+            current_subject = Some(subject);
-+        }
-+    }
-+}
-+
-+// Process TTL input
-+pub fn process_input<R: Read, A: Args>(reader: BufReader<R>, args: &A, colors: &config::ColorConfig) -> Result<()> {
-+    let mut parser = TurtleParser::new(reader, None);
-+
-+    if !args.expand() {
-+        // Collect triples and prefixes
-+        let mut triples = Vec::new();
-+        let mut prefixes = HashMap::new();
-+
-+        // Process each triple
-+        let mut callback = |triple: Triple| -> std::result::Result<(), TurtleError> {
-+            // Convert to owned triple
-+            let owned_triple = triple_to_owned(&triple);
-+            triples.push(owned_triple);
-+            Ok(())
-+        };
-+
-+        // Parse all triples
-+        parser.parse_all(&mut callback)?;
-+
-+        // Get prefixes from parser
-+        for (prefix, iri) in parser.prefixes() {
-+            prefixes.insert(prefix.to_string(), iri.to_string());
-+        }
-+
-+        // Print prefixes
-+        for (prefix, iri) in &prefixes {
-+            println!("{} {}: <{}> .",
-+                "PREFIX".color(colors.get_color("prefix")),
-+                prefix.color(colors.get_color("prefix")),
-+                iri);
-+        }
-+
-+        if !prefixes.is_empty() {
-+            println!(); // Add a blank line after prefixes
-+        }
-+
-+        // Print triples with prefixes
-+        print_triples(&triples, Some(&prefixes), colors);
-+    } else {
-+        // If expanding, print directly as we parse
-+        let mut triples = Vec::new();
-+
-+        // Process each triple
-+        let mut callback = |triple: Triple| -> std::result::Result<(), TurtleError> {
-+            // Convert to owned triple
-+            let owned_triple = triple_to_owned(&triple);
-+            triples.push(owned_triple);
-+            Ok(())
-+        };
-+
-+        // Parse all triples
-+        parser.parse_all(&mut callback)?;
-+
-+        // Print triples without prefixes
-+        print_triples(&triples, None, colors);
-+    }
-+
-+    Ok(())
-+}
diff --git a/Cargo.toml b/Cargo.toml
index 906ccd6..539f13d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -3,7 +3,7 @@ name = "rdfless"
 version = "0.1.0"
 edition = "2021"
 description = "A colorful TTL (Turtle) pretty printer for RDF data with ANSI colors"
-authors = ["rdfless Contributors"]
+authors = ["Lars Wilhelmsen"]
 license = "BSD-3-Clause"
 repository = "https://github.com/yourusername/rdfless"
 readme = "README.md"
diff --git a/src/config.rs b/src/config.rs
index 01103de..2325cd6 100644
--- a/src/config.rs
+++ b/src/config.rs
@@ -13,6 +13,23 @@ use dirs::home_dir;
 use serde_yaml2 as serde_yaml;
 #[derive(Debug, Serialize, Deserialize)]
+pub struct Config {
+    #[serde(default)]
+    pub colors: ColorConfig,
+    #[serde(default)]
+    pub expand: bool,
+}
+
+impl Default for Config {
+    fn default() -> Self {
+        Config {
+            colors: ColorConfig::default(),
+            expand: false,
+        }
+    }
+}
+
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct ColorConfig {
     pub subject: String,
     pub predicate: String,
@@ -71,7 +88,7 @@ pub fn string_to_color(color_name: &str) -> Color {
     }
 }
-pub fn load_config() -> Result<ColorConfig> {
+pub fn load_config() -> Result<Config> {
     let config_path = get_config_path()?;
     if !config_path.exists() {
@@ -81,20 +98,22 @@ pub fn load_config() -> Result<ColorConfig> {
     let config_str = fs::read_to_string(&config_path)
         .with_context(|| format!("Failed to read config file: {}", config_path.display()))?;
-    let config: ColorConfig = serde_yaml::from_str(&config_str)
+    let config: Config = serde_yaml::from_str(&config_str)
         .with_context(|| "Failed to parse config file")?;
     Ok(config)
 }
+
 fn get_config_path() -> Result<PathBuf> {
     let home = home_dir().context("Could not find home directory")?;
     let config_dir = home.join(".local").join("rdfless");
-    let config_path = config_dir.join("colors.yml");
+    let config_path = config_dir.join("config.yml");
     Ok(config_path)
 }
+
 fn create_default_config(config_path: &PathBuf) -> Result<()> {
     let config_dir = config_path.parent().unwrap();
@@ -103,7 +122,7 @@ fn create_default_config(config_path: &PathBuf) -> Result<()> {
             .with_context(|| format!("Failed to create config directory: {}", config_dir.display()))?;
     }
-    let default_config = ColorConfig::default();
+    let default_config = Config::default();
     let yaml = serde_yaml::to_string(&default_config)
         .context("Failed to serialize default config")?;
diff --git a/src/lib.rs b/src/lib.rs
index 0a29f8f..cf5e33b 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -16,7 +16,7 @@ pub mod config;
 // Define a trait for the Args interface
 pub trait Args {
-    fn expand(&self) -> bool;
+    fn expand(&self, config: &config::Config) -> bool;
 }
 // Re-export the types and functions needed for testing
@@ -206,10 +206,10 @@ pub fn print_triples(triples: &[OwnedTriple], prefixes: Option<&HashMap<String,
 }
 // Process TTL input
-pub fn process_input<R: Read, A: Args>(reader: BufReader<R>, args: &A, colors: &config::ColorConfig) -> Result<()> {
+pub fn process_input<R: Read, A: Args>(reader: BufReader<R>, args: &A, colors: &config::ColorConfig, config: &config::Config) -> Result<()> {
     let mut parser = TurtleParser::new(reader, None);
-    if !args.expand() {
+    if !args.expand(config) {
         // Collect triples and prefixes
         let mut triples = Vec::new();
         let mut prefixes = HashMap::new();
diff --git a/src/main.rs b/src/main.rs
index 0b7fc5f..c0da406 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -16,7 +16,7 @@ use std::io::{self, BufReader, IsTerminal, Read};
 use std::path::PathBuf;
 mod config;
-use config::{ColorConfig, load_config};
+use config::{Config, ColorConfig, load_config};
 /// A TTL (Turtle) pretty printer with ANSI colors
 #[derive(Parser, Debug)]
@@ -28,14 +28,22 @@ struct Args {
     /// Expand prefixes instead of showing PREFIX declarations
     #[arg(long)]
-    expand: bool,
+    expand: Option<bool>,
+}
+
+impl Args {
+    fn expand(&self, config: &Config) -> bool {
+        // Use command line value if provided, otherwise use config value
+        self.expand.unwrap_or(config.expand)
+    }
 }
 fn main() -> Result<()> {
     let args = Args::parse();
-    // Load color configuration
-    let colors = load_config()?;
+    // Load configuration
+    let config = load_config()?;
+    let colors = &config.colors;
     // Check if we should read from stdin or files
     if args.files.is_empty() {
@@ -43,7 +51,7 @@ fn main() -> Result<()> {
         if !io::stdin().is_terminal() {
             let stdin = io::stdin();
             let reader = BufReader::new(stdin);
-            process_input(reader, &args, &colors)?;
+            process_input(reader, &args, colors, &config)?;
         } else {
             eprintln!("No input files provided and no input piped to stdin.");
             eprintln!("Usage: cat file.ttl | rdfless [--expand]");
@@ -58,7 +66,7 @@ fn main() -> Result<()> {
             let file = File::open(file_path)
                 .with_context(|| format!("Failed to open file: {}", file_path.display()))?;
             let reader = BufReader::new(file);
-            process_input(reader, &args, &colors)?;
+            process_input(reader, &args, colors, &config)?;
         }
     }
@@ -90,10 +98,13 @@ enum ObjectType {
     Literal,
 }
-fn process_input<R: Read>(reader: BufReader<R>, args: &Args, colors: &ColorConfig) -> Result<()> {
+fn process_input<R: Read>(reader: BufReader<R>, args: &Args, colors: &ColorConfig, config: &Config) -> Result<()> {
     let mut parser = TurtleParser::new(reader, None);
-    if !args.expand {
+    // Determine if we should expand prefixes
+    let should_expand = args.expand(config);
+
+    if !should_expand {
         // Collect triples and prefixes
         let mut triples = Vec::new();
         let mut prefixes = HashMap::new();
diff --git a/tests/config_test.rs b/tests/config_test.rs
index c24b50e..72457ad 100644
--- a/tests/config_test.rs
+++ b/tests/config_test.rs
@@ -1,11 +1,40 @@
 use rstest::rstest;
-use rdfless::config::{ColorConfig, string_to_color};
+use rdfless::config::{Config, ColorConfig, string_to_color};
 use colored::Color;
+#[rstest]
+fn test_default_config() {
+    let config = Config::default();
+
+    // Test default expand value
+    assert_eq!(config.expand, false);
+
+    // Test default color config
+    assert_eq!(config.colors.subject, "blue");
+    assert_eq!(config.colors.predicate, "green");
+    assert_eq!(config.colors.object, "white");
+    assert_eq!(config.colors.literal, "red");
+    assert_eq!(config.colors.prefix, "yellow");
+    assert_eq!(config.colors.base, "yellow");
+}
+
+#[rstest]
+fn test_config_expand() {
+    // Test with expand=true
+    let mut config = Config::default();
+    config.expand = true;
+    assert_eq!(config.expand, true);
+
+    // Test with expand=false
+    let mut config = Config::default();
+    config.expand = false;
+    assert_eq!(config.expand, false);
+}
+
 #[rstest]
 fn test_default_color_config() {
     let config = ColorConfig::default();
-
+
     assert_eq!(config.subject, "blue");
     assert_eq!(config.predicate, "green");
     assert_eq!(config.object, "white");
@@ -23,7 +52,7 @@ fn test_default_color_config() {
 #[case("base", "yellow", Color::Yellow)]
 fn test_get_color(#[case] component: &str, #[case] color_name: &str, #[case] expected: Color) {
     let mut config = ColorConfig::default();
-
+
     // Override the default color for the test
     match component {
         "subject" => config.subject = color_name.to_string(),
@@ -34,7 +63,7 @@ fn test_get_color(#[case] component: &str, #[case] color_name: &str, #[case] exp
         "base" => config.base = color_name.to_string(),
         _ => {}
     }
-
+
     assert_eq!(config.get_color(component), expected);
 }
@@ -58,4 +87,4 @@ fn test_get_color(#[case] component: &str, #[case] color_name: &str, #[case] exp
 #[case("unknown", Color::White)] // Default for unknown colors
 fn test_string_to_color(#[case] color_name: &str, #[case] expected: Color) {
     assert_eq!(string_to_color(color_name), expected);
-}
\ No newline at end of file
+}
diff --git a/tests/parser_test.rs b/tests/parser_test.rs
index 749f04c..cf42c49 100644
--- a/tests/parser_test.rs
+++ b/tests/parser_test.rs
@@ -1,14 +1,14 @@
+use rdfless::triple_to_owned;
+use rio_api::model::Triple;
+use rio_api::parser::TriplesParser;
+use rio_turtle::{TurtleError, TurtleParser};
 use rstest::rstest;
 use std::io::BufReader;
-use rio_api::model::{Triple, Term, Literal, Subject};
-use rio_api::parser::TriplesParser;
-use rio_turtle::{TurtleParser, TurtleError};
-use rdfless::{OwnedTriple, triple_to_owned};
 #[rstest]
 fn test_turtle_parser_basic() {
     let ttl = r#"
-        @prefix ex: <http://example.org/> .
+        @prefix ex: <https://example.org/> .
         ex:subject ex:predicate "object" .
     "#;
@@ -17,7 +17,7 @@ fn test_turtle_parser_basic() {
     let mut parser = TurtleParser::new(reader, None);
     let mut triples = Vec::new();
-    let mut callback = |triple: Triple| -> std::result::Result<(), TurtleError> {
+    let mut callback = |triple: Triple| -> Result<(), TurtleError> {
         let owned_triple = triple_to_owned(&triple);
         triples.push(owned_triple);
         Ok(())
@@ -29,8 +29,8 @@ fn test_turtle_parser_basic() {
     let triple = &triples[0];
     assert_eq!(triple.subject_type, rdfless::SubjectType::NamedNode);
-    assert_eq!(triple.subject_value, "http://example.org/subject");
-    assert_eq!(triple.predicate, "http://example.org/predicate");
+    assert_eq!(triple.subject_value, "https://example.org/subject");
+    assert_eq!(triple.predicate, "https://example.org/predicate");
     assert_eq!(triple.object_type, rdfless::ObjectType::Literal);
     assert_eq!(triple.object_value, "object");
 }
@@ -39,7 +39,7 @@ fn test_turtle_parser_basic() {
 fn test_turtle_parser_with_prefixes() {
     let ttl = r#"
         @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
-        @prefix ex: <http://example.org/> .
+        @prefix ex: <https://example.org/> .
         ex:Resource a rdf:Class .
     "#;
@@ -48,7 +48,7 @@ fn test_turtle_parser_with_prefixes() {
     let mut parser = TurtleParser::new(reader, None);
     let mut triples = Vec::new();
-    let mut callback = |triple: Triple| -> std::result::Result<(), TurtleError> {
+    let mut callback = |triple: Triple| -> Result<(), TurtleError> {
         let owned_triple = triple_to_owned(&triple);
         triples.push(owned_triple);
         Ok(())
@@ -60,7 +60,7 @@ fn test_turtle_parser_with_prefixes() {
     let triple = &triples[0];
     assert_eq!(triple.subject_type, rdfless::SubjectType::NamedNode);
-    assert_eq!(triple.subject_value, "http://example.org/Resource");
+    assert_eq!(triple.subject_value, "https://example.org/Resource");
     assert_eq!(triple.predicate, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
     assert_eq!(triple.object_type, rdfless::ObjectType::NamedNode);
     assert_eq!(triple.object_value, "http://www.w3.org/1999/02/22-rdf-syntax-ns#Class");
@@ -74,13 +74,13 @@ fn test_turtle_parser_with_prefixes() {
     // Check the values
     assert_eq!(prefixes.get("rdf").unwrap(), "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
-    assert_eq!(prefixes.get("ex").unwrap(), "http://example.org/");
+    assert_eq!(prefixes.get("ex").unwrap(), "https://example.org/");
 }
 #[rstest]
 fn test_turtle_parser_with_blank_nodes() {
     let ttl = r#"
-        @prefix ex: <http://example.org/> .
+        @prefix ex: <https://example.org/> .
         _:blank ex:predicate "value" .
     "#;
@@ -89,7 +89,7 @@ fn test_turtle_parser_with_blank_nodes() {
     let mut parser = TurtleParser::new(reader, None);
     let mut triples = Vec::new();
-    let mut callback = |triple: Triple| -> std::result::Result<(), TurtleError> {
+    let mut callback = |triple: Triple| -> Result<(), TurtleError> {
         let owned_triple = triple_to_owned(&triple);
         triples.push(owned_triple);
         Ok(())
@@ -101,7 +101,7 @@ fn test_turtle_parser_with_blank_nodes() {
     let triple = &triples[0];
     assert_eq!(triple.subject_type, rdfless::SubjectType::BlankNode);
-    assert_eq!(triple.predicate, "http://example.org/predicate");
+    assert_eq!(triple.predicate, "https://example.org/predicate");
     assert_eq!(triple.object_type, rdfless::ObjectType::Literal);
     assert_eq!(triple.object_value, "value");
 }
@@ -109,7 +109,7 @@ fn test_turtle_parser_with_blank_nodes() {
 #[rstest]
 fn test_turtle_parser_with_literals() {
     let ttl = r#"
-        @prefix ex: <http://example.org/> .
+        @prefix ex: <https://example.org/> .
         @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
         ex:subject ex:string "simple string" .
@@ -121,7 +121,7 @@ fn test_turtle_parser_with_literals() {
     let mut parser = TurtleParser::new(reader, None);
     let mut triples = Vec::new();
-    let mut callback = |triple: Triple| -> std::result::Result<(), TurtleError> {
+    let mut callback = |triple: Triple| -> Result<(), TurtleError> {
         let owned_triple = triple_to_owned(&triple);
         triples.push(owned_triple);
         Ok(())
@@ -132,18 +132,18 @@ fn test_turtle_parser_with_literals() {
     assert_eq!(triples.len(), 3);
     // Check simple string literal
-    let simple_string = triples.iter().find(|t| t.predicate == "http://example.org/string").unwrap();
+    let simple_string = triples.iter().find(|t| t.predicate == "https://example.org/string").unwrap();
     assert_eq!(simple_string.object_type, rdfless::ObjectType::Literal);
     assert_eq!(simple_string.object_value, "simple string");
     // Check language-tagged string
-    let lang_string = triples.iter().find(|t| t.predicate == "http://example.org/langString").unwrap();
+    let lang_string = triples.iter().find(|t| t.predicate == "https://example.org/langString").unwrap();
     assert_eq!(lang_string.object_type, rdfless::ObjectType::Literal);
     assert_eq!(lang_string.object_value, "hello");
     assert_eq!(lang_string.object_language.as_deref(), Some("en"));
     // Check typed literal
-    let typed_literal = triples.iter().find(|t| t.predicate == "http://example.org/integer").unwrap();
+    let typed_literal = triples.iter().find(|t| t.predicate == "https://example.org/integer").unwrap();
     assert_eq!(typed_literal.object_type, rdfless::ObjectType::Literal);
     assert_eq!(typed_literal.object_value, "42");
     assert_eq!(typed_literal.object_datatype.as_deref(), Some("http://www.w3.org/2001/XMLSchema#integer"));
diff --git a/tests/process_test.rs b/tests/process_test.rs
index 9282de9..bf4abab 100644
--- a/tests/process_test.rs
+++ b/tests/process_test.rs
@@ -1,18 +1,17 @@
+use rdfless::config::{ColorConfig, Config};
+use rdfless::Args;
 use rstest::rstest;
+use std::io::Write;
 use std::io::{BufReader, Cursor};
 use tempfile::NamedTempFile;
-use std::io::Write;
-use std::fs::File;
-use rdfless::config::ColorConfig;
-use rdfless::Args;
 struct TestArgs {
-    expand: bool,
+    expand: Option<bool>,
 }
 impl Args for TestArgs {
-    fn expand(&self) -> bool {
-        self.expand
+    fn expand(&self, config: &Config) -> bool {
+        self.expand.unwrap_or(config.expand)
     }
 }
@@ -58,12 +57,13 @@ fn test_process_input_basic() {
     "#;
     let reader = BufReader::new(Cursor::new(ttl));
-    let args = TestArgs { expand: false };
+    let args = TestArgs { expand: Some(false) };
     let colors = ColorConfig::default();
+    let config = Config::default();
     // This test is more of a smoke test to ensure process_input doesn't panic
     // We can't easily capture the stdout in a unit test, so we just verify it doesn't error
-    let result = rdfless::process_input(reader, &args, &colors);
+    let result = rdfless::process_input(reader, &args, &colors, &config);
     assert!(result.is_ok());
 }
@@ -76,10 +76,11 @@ fn test_process_input_with_expand() {
     "#;
     let reader = BufReader::new(Cursor::new(ttl));
-    let args = TestArgs { expand: true };
+    let args = TestArgs { expand: Some(true) };
     let colors = ColorConfig::default();
+    let config = Config::default();
-    let result = rdfless::process_input(reader, &args, &colors);
+    let result = rdfless::process_input(reader, &args, &colors, &config);
     assert!(result.is_ok());
 }
@@ -94,10 +95,11 @@ fn test_process_input_with_file() {
     // Get a reference to the file
     let file = temp_file.reopen().unwrap();
     let reader = BufReader::new(file);
-    let args = TestArgs { expand: false };
+    let args = TestArgs { expand: Some(false) };
     let colors = ColorConfig::default();
+    let config = Config::default();
-    let result = rdfless::process_input(reader, &args, &colors);
+    let result = rdfless::process_input(reader, &args, &colors, &config);
     assert!(result.is_ok());
 }
@@ -117,9 +119,40 @@ fn test_process_input_with_multiple_triples() {
     "#;
     let reader = BufReader::new(Cursor::new(ttl));
-    let args = TestArgs { expand: false };
+    let args = TestArgs { expand: Some(false) };
+    let colors = ColorConfig::default();
+    let config = Config::default();
+
+    let result = rdfless::process_input(reader, &args, &colors, &config);
+    assert!(result.is_ok());
+}
+
+#[rstest]
+fn test_process_input_with_config_expand() {
+    let ttl = r#"
+        @prefix ex: <http://example.org/> .
+
+        ex:subject ex:predicate "object" .
+    "#;
+
+    let reader = BufReader::new(Cursor::new(ttl));
+    // No command line expand option provided
+    let args = TestArgs { expand: None };
     let colors = ColorConfig::default();
-    let result = rdfless::process_input(reader, &args, &colors);
+    // Config with expand=true
+    let mut config = Config::default();
+    config.expand = true;
+
+    let result = rdfless::process_input(reader, &args, &colors, &config);
+    assert!(result.is_ok());
+
+    // Test with config expand=false
+    let reader = BufReader::new(Cursor::new(ttl));
+    let args = TestArgs { expand: None };
+    let mut config = Config::default();
+    config.expand = false;
+
+    let result = rdfless::process_input(reader, &args, &colors, &config);
     assert!(result.is_ok());
 }
